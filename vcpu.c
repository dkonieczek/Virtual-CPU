/**
Dennis Konieczek - kncd0034 / 823-534-706
Nikolas Spendik  - spnn0141 / 823-195-722
CENG 356 - Final Project - Virtual CPU
April 27th, 2016
*/
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <stdint.h>
#include <stdbool.h>

#define MAX32 2147483647

int32_t R0, R1, R2, R3, R4, R5, R6, // General purpose registers
R7, R8, R9, R10, R11, R12;
int32_t R13; // SP - stack pointer
int32_t R14; // LR - link register
int32_t R15; // PC - program counter
bool S, Z, C; //CCR flags
int32_t MBR, MAR; //Memory buffer register , Memory address register
int16_t IR0, IR1; //26 bit registers
bool IR; //IR active flag


int iscarry(unsigned long op1, unsigned long op2, unsigned C);
void dumpMemory(void * memory, unsigned offset, unsigned length);
void go(void);
int LoadFile(void * memory, unsigned int max);
void memoryModify(void * memory, unsigned offset);
void displayRegisters(void);
void trace(void);
void WriteFile(void * memory);
void resetRegisters(void);
void help(void);
void fetch(void);

char memory[16384];
FILE * fp;
char filename[100];
unsigned int bytesToWrite;
int read;
int size;
unsigned offset;
unsigned length;
unsigned mod;
unsigned char modifyTo[3];

int main(void)
{
	char command;
	/*display menu*/
	printf("By: Dennis Konieczek and Nikolas Spendik\n");
	printf("d\t dump memory\n");
	printf("g\t go - run the entire program\n");
	printf("l\t load a file into memory\n");
	printf("m\t memory modify\n");
	printf("q\t quit\n");
	printf("r\t display registers\n");
	printf("t\t trace - execute one instruction\n");
	printf("w\t write file\n");
	printf("z\t reset all registers to zero\n");
	printf("?, h\t display list of commands\n");

	/*prompt for command and execute corresponding task*/
	while (1) {
		printf("\n>>Enter command: ");
		scanf(" %c", &command);
		switch (command) {
			case 'd':
			case 'D':
			printf("\n>>Enter offset: ");
			scanf(" %x", &offset);
			printf("\n>>Enter length: ");
			scanf(" %x", &length);
			dumpMemory(&memory, offset, length);
			break;
			case 'g':
			case 'G':
			go();
			break;
			case 'l':
			case 'L':
			LoadFile(&memory, sizeof(memory));
			break;
			case 'm':
			case 'M':
			printf("\n>>Enter starting address: ");
			scanf(" %x", &offset);
			memoryModify(&memory, offset);
			break;
			case 'q':
			case 'Q':
			printf("Exiting...  \n");
			exit(0);
			break;
			case 'r':
			case 'R':
			displayRegisters();
			break;
			case 't':
			case 'T':
			trace();
			break;
			case 'w':
			case 'W':
			WriteFile(&memory);
			break;
			case 'z':
			case 'Z':
			resetRegisters();
			break;
			case '?':
			case 'h':
			case 'H':
			help();
			break;
			default:
			printf("!wrong command!");
			break;
		}
	}
	printf("\n");
	return 0;
}

/*
iscarry()- determine if carry is generated by addition: op1+op2+C
C can only have value of 1 or 0.
*/
int iscarry(unsigned long op1, unsigned long op2, unsigned C) {

	if ((op2 == MAX32) && (C == 1))
	return(1); // special case where op2 is at MAX32
	return((op1 > (MAX32 - op2 - C)) ? 1 : 0);
}



/*
Prompt user for offset to start at.
Prompt user for length to dump.
Dumped data will contain the contents of memory from the LoadFile function
*/
void dumpMemory(void * memory, unsigned offset, unsigned length) {

	unsigned int i, j;

	for (i = offset; i < length + ((length % 8) ? (8 - length % 8) : 0); i++)
	{
		/*display offset*/
		if (i % 8 == 0) {
			printf("0x%04x: ", i);
		}
		/*display hex content at corresponding offset*/
		if (i < length) {
			printf("%02x ", 0xFF & ((char*)memory)[i]);
		}
		else {
			printf("   ");
		}
		/*display ASCII content at corresponding offset*/
		if (i % 8 == (8 - 1)) {
			printf("\n       \t");
			for (j = i - (8 - 1); j <= i; j++) {
				if (j >= length) {
					putchar(' ');
				}
				else if (isprint(((char*)memory)[j])) {
					putchar(0xFF & ((char*)memory)[j]);
					printf("  ");
				}
				else {
					putchar('.');
					printf("  ");
				}
			}
			putchar('\n');
		}
	}
}

void go(void) {

	while (1) {
		trace();
		if (S != 0) {
			printf("Program is done\n\n");
			break;
		}
	}


	resetRegisters();
	displayRegisters();
}

/*
Prompts user to enter name of file to load.
Checks if file will be truncated.
Reads a max specified number of bytes from file.
Displays contents read and number of bytes read in decimal and hex.
Returns number of bytes read in decimal.
*/
int LoadFile(void * memory, unsigned int max) {

	printf("\n>>Enter file name to load: ");
	scanf("%s", &filename);
	/*open file*/
	fp = fopen(filename, "r+b");
	if (fp == NULL) {
		perror("Error opening file");
		return(-1);
	}
	/*get size of file*/
	fseek(fp, 0L, SEEK_END);
	size = ftell(fp);
	fseek(fp, 0L, SEEK_SET);
	if (size > max) {
		printf("!Warning! - File has been truncated!\n");
	}
	/*read contents of file and place into memory*/
	read = fread(memory, 1, max, fp);
	if (read <= 0) {
		printf("!Warning! - File is empty!\n");
	}
	else {
		printf("%s\n", memory);
	}
	fclose(fp);
	/*display number of bytes read into memory*/
	printf("read in %d bytes (%x hex)\n", read, read);
	return read;
}


/*
Prompts user for offset and displays content at that offset.
Prompts user for a value to modify the offset with.
Increments offset to move to the next byte in memory.
*/
void memoryModify(void * memory, unsigned offset) {

	char *p;
	int c;

	while (1) {
		/*terminate new line in input buffer stdin*/
		while ((c = getchar()) != '\n' && c != EOF);
		/*display offset and content at corresponding offset*/
		printf("\n0x%04X: %02X \n>>Modify to: ", offset, *((unsigned char*)memory + offset));
		/*prompt for value to modify offset with*/
		fgets(modifyTo, 3, stdin);
		/*exit if value is '.'*/
		if (modifyTo[0] == '.') {
			break;
		}
		/*convert string of hex characters to hex bytes and check if valid hex bytes*/
		if (sscanf(modifyTo, "%x", &mod) == 0) {
			continue;
		}
		/*modify memory contents at offset*/
		*((unsigned char*)memory + offset) = mod;
		/*increment to next byte in memory*/
		++offset;
	}
}

unsigned char temp[3];
unsigned char temp2[1];
unsigned char temp3[3];
unsigned char temp4[3];
unsigned char temp5[1];
unsigned char temp6[1];
/*
Gets and executes next command
*/
void fetch(void) {

	MAR = R15;


	temp[0] = memory[MAR];
	temp[1] = memory[MAR + 1];
	temp[2] = memory[MAR + 2];
	temp[3] = memory[MAR + 3];

	MBR = strtol(temp, 0, 16);

	IR0 = MBR & 0x00f0;
	IR1 = MBR & 0x000f;

	//R0 = 5;

	switch (MBR & 0xf000)
	{
		case 0x0000: //Data processing
		switch (MBR & 0x0f00)
		{

			case 0x0100:// ADD
			temp5[0] = memory[MAR + 2]; //get the immediate value

			switch (IR1 & 0x000f)
			{
				case 0x0000:  //destination r0
				R0 += strtol(temp5, 0, 16);
				break;
				case 0x0001:  //destination r1
				R1 += strtol(temp5, 0, 16);
				break;
				case 0x0002:  //destination r2
				R2 += strtol(temp5, 0, 16);
				break;
				default:
				break;
			}
			break;

			case 0x0200: //SUB
			//	R0 = 10;
			temp6[0] = memory[MAR + 2]; //get the immediate value

			switch (IR1 & 0x000f)
			{
				case 0x0000:  //destination r0
				R0 -= strtol(temp6, 0, 16);
				break;
				case 0x0001:  //destination r1
				R1 -= strtol(temp6, 0, 16);
				break;
				case 0x0002:  //destination r2
				R2 -= strtol(temp6, 0, 16);
				break;
				default:
				break;
			}
			break;
			default:
			break;
		}
		break;


		case 0x5000: //ADC

		switch (MBR & 0x0f00)
		{
			case 0x0100: //register to register = 0x51--
			switch (IR0)
			{
				case 0x0000: //source (r0)

				switch (IR1)
				{
					case 0x0000: //destination (r0)
					R0 += (iscarry(R0, R0, C)) ? R0 + 1 : R0; //Rd := Rd + Rn + C
					break;
					case 0x0001: //destination (r1)
					R1 += (iscarry(R0, R1, C)) ? R0 + 1 : R0; //Rd := Rd + Rn + C
					break;
					case 0x0002: //destination (r2)
					R2 += (iscarry(R0, R2, C)) ? R0 + 1 : R0; //Rd := Rd + Rn + C
					break;
					default:
					break;
				}
				break;
				default:
				break;
			}
			switch (IR0)
			{
				case 0x0010: //source (r1)

				switch (IR1)
				{
					case 0x0000: //destination (r0)
					R0 += (iscarry(R1, R0, C)) ? R1 + 1 : R1; //Rd := Rd + Rn + C
					break;
					case 0x0001: //destination (r1)
					R1 += (iscarry(R1, R1, C)) ? R1 + 1 : R1; //Rd := Rd + Rn + C
					break;
					case 0x0002: //destination (r2)
					R2 += (iscarry(R1, R2, C)) ? R1 + 1 : R1; //Rd := Rd + Rn + C
					break;
				}
				break;
				default:
				break;
			}
			switch (IR0)
			{
				case 0x0020: //source (r2)

				switch (IR1)
				{
					case 0x0000: //destination (r0)
					R0 += (iscarry(R2, R0, C)) ? R2 + 1 : R2; //Rd := Rd + Rn + C
					break;
					case 0x0001: //destination (r1)
					R1 += (iscarry(R2, R1, C)) ? R2 + 1 : R2; //Rd := Rd + Rn + C
					break;
					case 0x0002: //destination (r2)
					break;
					R2 += (iscarry(R2, R2, C)) ? R2 + 1 : R2; //Rd := Rd + Rn + C
					default:
					break;
				}
				break;
				default:
				break;
			}

			break;


			case 0x0200: //immediate addressing = 0x52--

			temp2[0] = memory[MAR + 2]; //get the immediate value

			switch (IR1 & 0x000f)
			{
				case 0x0000:  //destination r0
				R0 += (iscarry(R0, strtol(temp2, 0, 16), C)) ? strtol(temp2, 0, 16) + 1 : strtol(temp2, 0, 16); //Rd := Rd + Rn + C
				break;
				case 0x0001:  //destination r1
				R1 += (iscarry(R1, strtol(temp2, 0, 16) , C)) ? strtol(temp2, 0, 16) + 1 : strtol(temp2, 0, 16); //Rd := Rd + Rn + C
				break;
				case 0x0002:  //destination r2
				R2 += (iscarry(R2, strtol(temp2, 0, 16), C)) ? strtol(temp2, 0, 16) + 1 : strtol(temp2, 0, 16); //Rd := Rd + Rn + C
				break;
				default:
				break;
			}
			break;
			default:
			break;
		}



		break;

		//////

		case 0x2000: //LOAD/STORE
		R2 = 4;
		switch (IR0)
		{
			case 0x0000 : //source (r0)

			switch (IR1)
			{
				case 0x0000: //destination (r0)
				R0 = R0;
				break;
				case 0x0001: //destination (r1)
				R1 = R0;
				break;
				case 0x0002: //destination (r2)
				R2 = R0;
				break;
				default:
				break;
			}
			break;
			default:
			break;
		}
		switch (IR0)
		{
			case 0x0010: //source (r1)

			switch (IR1)
			{
				case 0x0000: //destination (r0)
				R0 = R1;
				break;
				case 0x0001: //destination (r1)
				R1 = R1;
				break;
				case 0x0002: //destination (r2)
				R2 = R1;
				break;
			}
			break;
			default:
			break;
		}
		switch (IR0)
		{
			case 0x0020: //source (r2)

			switch (IR1)
			{
				case 0x0000: //destination (r0)
				R0 = R2;
				break;
				case 0x0001: //destination (r1)
				R1 = R2;
				break;
				case 0x0002: //destination (r2)
				R2 = R2;
				break;
				default:
				break;
			}
			break;
			default:
			break;
		}




		break;//end of load/store

		case 0xe000: //STOP

		S = 1;
		displayRegisters();
		exit(1);
		break;



		default:
		break;
	}

	switch (MBR & 0xf000)
	{
		case 0xC000: //Unconditional Branch
		temp3[0] = memory[MAR + 1];
		temp3[1] = memory[MAR + 2];
		temp3[2] = memory[MAR + 3];

		R1 =  strtol(temp3,0,16);
		R15 = R1;
		break;
	}

	switch (MBR & 0xf000)
	{
		case 0x8000: //Conditional Branch

		switch (MBR & 0x0f00)
		{
			case 0x0100: //check if zero flag is set

			Z=1;
			if (Z != 0) {


				temp4[0] = memory[MAR + 2];
				temp4[1] = memory[MAR + 3];

				R15 = strtol(temp4,0,16);
				break;
			} else {
				break;
			}

		}
	}

	R15 += 5;

}


void trace(void) {
	fetch();
	displayRegisters();
}

/*
Prompts user for filename to write to.
Prompts user for number of bytes to write to file.
Writes certain amount of bytes of a hardcoded message to the file.
*/
void WriteFile(void * memory) {

	/*prompt for file name to write to and max number of bytes to write*/
	printf("\n>>Enter file name to write to: ");
	scanf("%s", &filename);
	printf("\n>>Enter number of bytes to write: ");
	scanf("%d", &bytesToWrite);
	fp = fopen(filename, "w+b");
	if (fp == NULL) {
		perror("Error opening file");
	}
	/*write a message with a max length of byteToWrite to file*/
	fwrite("0001\n0010\n0011", bytesToWrite, 1, fp);
	fclose(fp);
	printf("wrote to file\n");
}

/*
Dump all registers
*/
void displayRegisters(void) {

	printf("R0: %x\tR1: %x\tR2: %x\tR3: %x\n", R0, R1, R2, R3);
	printf("R4: %x\tR5: %x\tR6: %x\tR7: %x\n", R4, R5, R6, R7);
	printf("R8: %x\tR9: %x\tR10: %x\tR11: %x\tR12: %x\n", R8, R9, R10, R11, R12);
	printf("R13(SP): %x\tR14(LR): %x\tR15(PC): %x\n", R13, R14, R15);
	printf("MBR: %x\tMAR: %x\tIR0: %x\tIR1: %x\n", MBR, MAR, IR0, IR1);
	printf("S: %x\tZ: %x\tC: %x\tIR: %x\n", S, Z, C, IR);
}

/*
Reset all registers
*/
void resetRegisters(void) {
	R0 = 0;
	R1 = 0;
	R2 = 0;
	R3 = 0;
	R4 = 0;
	R5 = 0;
	R6 = 0;
	R7 = 0;
	R8 = 0;
	R9 = 0;
	R10 = 0;
	R11 = 0;
	R12 = 0;
	R13 = 0;
	R14 = 0;
	R15 = 0;
	MBR = 0;
	MAR = 0;
	IR0 = 0;
	IR1 = 0;
	S = false;
	Z = false;
	C = false;
	IR = false;
}

/*
Help menu
*/
void help(void) {
	printf(" l - load a file into memory \n\t Specify name of file to load \n\t Opens file and displays contents \n\t Also displays the amount of bytes read in decimal and hex\n\n");
	printf(" w - write contents to file \n\t Specify name of file to write to & number of bytes to write \n\n");
	printf(" d - dump content of memory \n\t Specify offset to start at & Specify length to display \n\n");
	printf(" m - modify content of memory \n\t Specify offset to start at & Specify value to modify offset with. \n\t Increment to next byte. Enter '.' when finished \n\n");
	printf(" r - display registers \n\t Dumps all registers and their value are the current runtime \n\n");
	printf(" t - trace \n\t Step through each instruction \n\n");
	printf(" z - reset registers \n\t Reset all registers to 0 \n\n");
	printf(" g - go \n\t Run the entire program \n\n");
	printf(" q - quit \n\t quit the program \n\n");
}
